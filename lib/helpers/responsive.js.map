{"version":3,"file":"responsive.js","sources":["../../src/helpers/responsive.ts"],"sourcesContent":["import { cloneLayout, compact, correctBounds } from './common'\n\nimport type { Breakpoint, Breakpoints, Layout, ResponsiveLayout } from './types'\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param   breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param   width Screen width.\n * @return        Highest breakpoint that is less than width.\n */\nexport function getBreakpointFromWidth(breakpoints: Breakpoints, width: number): Breakpoint {\n  const sorted = sortBreakpoints(breakpoints)\n  let matching = sorted[0]\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i]\n    if (width > breakpoints[breakpointName]) matching = breakpointName\n  }\n  return matching\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param   breakpoint Breakpoint name.\n * @param   cols       Map of breakpoints to cols.\n * @return             Number of cols.\n */\nexport function getColsFromBreakpoint(breakpoint: Breakpoint, cols: Breakpoints): number {\n  if (!cols[breakpoint]) {\n    throw new Error(\n      'ResponsiveGridLayout: `cols` entry for breakpoint ' + breakpoint + ' is missing!'\n    )\n  }\n  return cols[breakpoint]\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  orgLayout     Original layout.\n * @param  layouts     Existing layouts.\n * @param  breakpoints All breakpoints.\n * @param  breakpoint New breakpoint.\n * @param  breakpoint Last breakpoint (for fallback).\n * @param  cols       Column count at new breakpoint.\n * @param  verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return              New layout.\n */\nexport function findOrGenerateResponsiveLayout(\n  orgLayout: Layout,\n  layouts: ResponsiveLayout,\n  breakpoints: Breakpoints,\n  breakpoint: Breakpoint,\n  lastBreakpoint: Breakpoint,\n  cols: number,\n  verticalCompact: boolean\n): Layout {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint])\n  // Find or generate the next layout\n  let layout = orgLayout\n\n  const breakpointsSorted = sortBreakpoints(breakpoints)\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint))\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i]\n    if (layouts[b]) {\n      layout = layouts[b]\n      break\n    }\n  }\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, { cols }), verticalCompact)\n}\n\nexport function generateResponsiveLayout(\n  layout: Layout,\n  breakpoints: Breakpoints,\n  breakpoint: Breakpoint,\n  lastBreakpoint: Breakpoint,\n  cols: number,\n  verticalCompact: boolean\n): Layout {\n  // If it already exists, just return it.\n  /* if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint]; */\n  /* const breakpointsSorted = sortBreakpoints(breakpoints);\nconst breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\nfor (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n  const b = breakpointsAbove[i];\n  if (layouts[b]) {\n    layout = layouts[b];\n    break;\n  }\n} */\n  layout = cloneLayout(layout || []) // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, { cols }), verticalCompact)\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  breakpoints Key/value pair of breakpoint names to widths.\n * @return              Sorted breakpoints.\n */\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint> {\n  const keys = Object.keys(breakpoints) as Array<Breakpoint>\n  return keys.sort((a, b) => breakpoints[a] - breakpoints[b])\n}\n"],"names":["getBreakpointFromWidth","breakpoints","width","sorted","sortBreakpoints","matching","i","len","breakpointName","getColsFromBreakpoint","breakpoint","cols","findOrGenerateResponsiveLayout","orgLayout","layouts","lastBreakpoint","verticalCompact","cloneLayout","layout","breakpointsSorted","breakpointsAbove","b","compact","correctBounds","a"],"mappings":"+GAWgB,SAAAA,EAAuBC,EAA0BC,EAA2B,CACpF,MAAAC,EAASC,EAAgBH,CAAW,EACtC,IAAAI,EAAWF,EAAO,CAAC,EACvB,QAASG,EAAI,EAAGC,EAAMJ,EAAO,OAAQG,EAAIC,EAAKD,IAAK,CAC3C,MAAAE,EAAiBL,EAAOG,CAAC,EAC3BJ,EAAQD,EAAYO,CAAc,IAAcH,EAAAG,EAAA,CAE/C,OAAAH,CACT,CAQgB,SAAAI,EAAsBC,EAAwBC,EAA2B,CACnF,GAAA,CAACA,EAAKD,CAAU,EAClB,MAAM,IAAI,MACR,qDAAuDA,EAAa,cACtE,EAEF,OAAOC,EAAKD,CAAU,CACxB,CAiBO,SAASE,EACdC,EACAC,EACAb,EACAS,EACAK,EACAJ,EACAK,EACQ,CAER,GAAIF,EAAQJ,CAAU,SAAUO,EAAAA,YAAYH,EAAQJ,CAAU,CAAC,EAE/D,IAAIQ,EAASL,EAEP,MAAAM,EAAoBf,EAAgBH,CAAW,EAC/CmB,EAAmBD,EAAkB,MAAMA,EAAkB,QAAQT,CAAU,CAAC,EACtF,QAASJ,EAAI,EAAGC,EAAMa,EAAiB,OAAQd,EAAIC,EAAKD,IAAK,CACrD,MAAAe,EAAID,EAAiBd,CAAC,EACxB,GAAAQ,EAAQO,CAAC,EAAG,CACdH,EAASJ,EAAQO,CAAC,EAClB,KAAA,CACF,CAEO,OAAAH,EAAAD,EAAAA,YAAYC,GAAU,EAAE,EAC1BI,EAAAA,QAAQC,EAAAA,cAAcL,EAAQ,CAAE,KAAAP,CAAK,CAAC,EAAGK,CAAe,CACjE,CAkCO,SAASZ,EAAgBH,EAA6C,CAEpE,OADM,OAAO,KAAKA,CAAW,EACxB,KAAK,CAACuB,EAAGH,IAAMpB,EAAYuB,CAAC,EAAIvB,EAAYoB,CAAC,CAAC,CAC5D"}